<html> 
<head></head>
<body>

<h1>Entry Level</h1>

<ul>
    <li>Choosing an appropriate IDE (Integrated Development Environment</li>
    <li>Explain what namespace is; explain what a class is and its relation to objects</li>
    <li>Intoducing how to add useful comments</li>
    <li>Intro to Console.WriteLine, Console.Write, Console.ReadLine, and Console.Read</li>
    <li>Intro to reading from and writing to a file</li>
    <li>Intro to data types, variables, fields, and concatination</li>
    <li>Intro to simple operators</li>
    <li>Intro to if/else and conditional statements + switch</li>
    <li>Intro to utilizing C# libraries</li>
    <li>Intro to simple arrays and targetting specific indexes</li>
</ul>
<h2></h2>

<h2>Simple Operators and Expressions</h2>

<h3>Simple Operators</h3>
<p>C# provides a number of operators. Many of them are supported by the built-in types and allow you to perform basic operations with
     values of those types.</p>

     <p>C# operators by group</p>
     <ul>
         <li>Arithmetic Operators</li>
         <li>Comparison Operators</li>
         <li>Boolean Logical Operators</li>
         <li>Bitwise and Shift Operators</li>
         <li>Equality Operators</li>
     </ul>
     <h4>Arithmetic Operators</h4>
     <p>Arithmetic Operations can be split up between Unary and Binary numeric types</p>
     <h6>Unary</h6>
     <ul>
         <li>++ (increment)</li>
         <li>-- (decrement)</li>
         <li>+ (plus)</li>
         <li>- (minus)</li>
     </ul>
     <h6>Binary</h6>
     <ul>
         <li>* (multiplication)</li>
         <li>/ (division)</li>
         <li>% (remainder)</li>
         <li>+ (addition)</li>
         <li>- (subtraction)</li>
     </ul>

     <h4>Comparison Operators</h4>
     <p>The < (less than), > (greater than), <= (less than or equal), and >= (greater than or equal) comparison, also known as relational, 
        operators compare their operands. Those operators are supported by all integral and floating-point numeric types.</p>
        
        <h6>List of Comparison Operators</h6>
        <ul>
            <li> < - returns true if its left-hand operand is less than its right-hand operand, false otherwise</li>
            <li> > - retruns true if its left-hand operand is greater than its right-hand operan, false otherwise</li>
            <li> <= - returns ture if its left-hand operand is less than or equal to its right-hand operand, false otherwise</li>
            <li> >= - returns true if its left-hand operand is greater than or equal to its right-hand operand, false otherwise</li>
        </ul>

    <h5>Important Operator Overloadability note</h5>
        <p>
            A user-defined type can overload the <, >, <=, and >= operators.
            
            If a type overloads one of the < or > operators, it must overload both < and >. If a type overloads one of the <= or >= operators, 
            it must overload both <= and >=.</p>

     <h4>Boolean Logical Operators</h4>
     <h6> Unary B.L.O. </h6>
     <ul>
         <li>! (logical negation) operators</li>
     </ul>

     <h6> Binary B.L.O</h6>
     <ul>
         <li>& (logical AND)</li>
         <li>| (logical OR)</li>
         <li> ^ (logical exclusive OR)</li>
         <li> && (conditional logical AND)</li>
         <li>|| (conditional logical OR)</li>
     </ul>

     <h4>Bitwise and Shift Operators</h4>
     <h6>Unary B.S.O</h6>
     <ul>
         <li>~ (bitwise complement) operator</li>
     </ul>
     <h6>Binary B.S.O</h6>
     <ul>
         <li> << (left shift)</li>
         <li> >> (right shift)</li>
         <li> & (logical AND)</li>
         <li> | (logical OR)</li>
         <li> ^ (logical exclusive OR)</li>
     </ul>
     <h4>Equality Operators</h4>
     <p>The == (equality) and != (inequality) operators check if their operands are equal or not.</p>

<h2>if/else and Conditional+Switch statements</h2>

<p>A statement that can be executed based on a condition is known as a “Conditional Statement”. The statement is often a block of code.

    The following are the 2 types:
    Conditional Branching
    Conditional Looping

    Conditional Branching
    This statement allows you to branch your code depending on whether or not a certain condition is met.
    
    In C# are the following 2 conditional branching statements:
    
    1. IF statement
    2. Switch statement</p>

<h3>If statement</h3>
<p>C# if else statement is a common selection statement. The if else in C# statement checks a Boolean expression and executes 
    the code based on if the expression is true or false. The if part of the code executes when the value of the 
    expression is true. The else part of the code is executed when the value of the expression is false. The else part 
    of the if..else is optional.</p>

<h3>Switch Statement</h3>
<p>In C#, Switch statement is a multiway branch statement. It provides an efficient way to transfer the execution to different 
    parts of a code based on the value of the expression. The switch expression is of integer type such as int, char, byte, or short, 
    or of an enumeration type, or of string type. The expression is checked for different cases and the one match is executed.</p>

    <p>Important points to remember on the list below.</p>
<ul>
    <li>In C#, duplicate case values are not allowed.</li>
    <li>The data type of the variable in the switch and value of a case must be of the same type.</li>
    <li>The value of a case must be a constant or a literal. Variables are not allowed.</li>
    <li>The break in switch statement is used to terminate the current sequence.</li>
    <li>The default statement is optional and it can be used anywhere inside the switch statement.</li>
    <li>Multiple default statements are not allowed.</li>
</ul>

<h2>C# libraries</h2>

<h2>Arrays and Targetting Indexes</h2>

<h3>Arrays</h3>
<p>An array stores lists of values in a specific order.</p>
<p>Example: local myArray = {"item1", "item2", 12, Random.Part, myVariable}</p>
<p>In the provided example, all values are inside "{}" and separated by commas.</p>

<h3>Indexes</h3>
<p>Indexers are a syntactic convenience that enable you to create a class, struct, or interface that client 
    applications can access as an array. The compiler will generate an Item property (or an alternatively named property if 
    IndexerNameAttribute is present), and the appropriate accessor methods.
     Indexers are most frequently implemented in types whose primary purpose is to encapsulate an internal collection or array. </p>

<p>An Indexer can hold multiple values.</p>

<p>For example, suppose you have a class TempRecord that represents the temperature in Fahrenheit as 
    recorded at 10 different times during a 24-hour period. The class contains a temps array of type float[] 
    to store the temperature values. By implementing an indexer in this class, clients can access the temperatures 
    in a TempRecord instance as float temp = tempRecord[4] instead of as float temp = tempRecord.temps[4]. 
    The indexer notation not only simplifies the syntax for client applications; it also makes the class, and its 
    purpose more intuitive for other developers to understand.

    To declare an indexer on a class or struct, use the "this" keyword</p>

    <p>List of Indexer qualities.</p>
<ul>
    <li>Allows elements of an internal collection of an object to be accessed by using array notation on the object itself.</li>
<li>Accessed through an index.</li>
<li>Must be an instance member.</li>
<li>A get accessor of an indexer has the same formal paremeter list as the indexer.</li>
<li>A set accessor of an indexer has the same formal parameter list as the indexer, and also to the value parameter.</li>
<li>Supports expression bodied members for get only indexers.</li>
</ul>






</body>