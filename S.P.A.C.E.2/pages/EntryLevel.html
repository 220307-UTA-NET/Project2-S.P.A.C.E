<html> 
<head></head>
<body>

<h1>Entry Level</h1>

<ol>
    <li>Choosing an appropriate IDE (Integrated Development Environment</li>
    <li>Explain what namespace is; explain what a class is and its relation to objects</li>
    <li>Intoducing how to add useful comments</li>
    <li>Intro to Console.WriteLine, Console.Write, Console.ReadLine, and Console.Read</li>
    <li>Intro to reading from and writing to a file</li>
    <li>Intro to data types, variables, fields, and concatination</li>
    <li>Intro to simple operators</li>
    <li>Intro to if/else and conditional statements + switch</li>
    <li>Intro to utilizing C# libraries</li>
    <li>Intro to simple arrays and targetting specific indexes</li>
</ol>
<h2>Data Types, Variables, Fields, and Concatination</h2>

<h3>Data Types</h3>
<h6>Data Types List + Description</h6>
<ul>
    <li>int (Stores whole numbers from -2, 147, 483, 648 to 2,123,123,123</li>
    <li>long (Stores whole numbers from -9, 234, 456, 012, 900, to 4,222,222,222,222,222,222</li>
    <li>float (Stores fractional numbers. Sufficient for storing 6 to 7 decimal digits</li>
    <li>double (Stores fractional numbers. Sufficient for storing 15 decimal digits</li>
    <li>bool (Stores true or false values</li>
    <li>char (Stores a single character/letter, surrounded by single quotes</li>
    <li>string (Stores a sequence of characters, surrounded by double quotes</li>
</ul>
<h4>Numbers</h4>
<p>Number types are divided into two groups:
    -Integer types stores whole numbers, positive or negative (such as 123 or -456), without decimals. Valid types are int and long. Which type you should use, depends on the numeric value.
    -Floating point types represents numbers with a fractional part, containing one or more decimals. Valid types are float and double.</p>

<h4>Integer Types</h4>
<h5>int</h5>
<p>The int data type can store whole numbers from -2147483648 to 2147483647. In general, and in our tutorial, the int data type is the
     preferred data type when we create variables with a numeric value.</p>
<h5>Long</h5>
<p>The long data type can store whole numbers from -9223372036854775808 to 9223372036854775807. This is used when int is not large 
    enough to store the value. Note that you should end the value with an "L"</p>

<h4>Floating Point Types</h4>
<p>You should use a floating point type whenever you need a number with a decimal, such as 9.99 or 3.14515.
The float and double data types can store fractional numbers. Note that you should end the value with an "F" for floats and "D" 
for doubles</p>
<h5>Scientific Numbers</h5>
<p>A floating point number can also be a scientific number with an "e" to indicate the power of 10</p>

<h4>Booleans</h4>
-A boolean data type is declared with the bool keyword and can only take the values true or false.
-Boolean values are mostly used for conditional testing

<h4>Characters</h4>
<p>The char data type is used to store a single character. The character must be surrounded by single quotes, like 'A' or 'c'</p>

<h4>Strings</h4>
<p>The string data type is used to store a sequence of characters (text). String values must be surrounded by double quotes("").</p>

<h3>Variables</h3>
<p>Variables are specific names given to locations in the memory for storing and dealing with data. The values of a variable can be 
    changed or reused as many times as possible. Every variable name has a specific type that resolves the size and layout of memory 
    the variable will hold as well as the range of values that variable within your program can hold. Also, programmers can determine 
    which variables can be applied to which type of operation.</p>
    <h6>Types of C# Variables</h6>
    <ul>
        <li>Integral Types - (sbyte, byte, ushort, int, uint, long, ulong, and char)</li>
        <li>Floating-point Types - (float and double)</li>
        <li>Decimal Types - (Decimal)</li>
        <li>Boolean Types - (True or False values, as assigned)</li>
        <li>Nullable Types - (Nullable data types)</li>
    </ul>

<h4>Defining Variables in C#</h4>
<p>For implementing variables in a C# program, you have to define them before use. To do this, the syntax is: <data_type> <variable_names>; </variable_names></p>
<h4>Initializing Variables in C#</h4>
<p>A C #variable gets initialized using the assignment operator, which is the equal sign. We will learn more about different operators in the subsequent chapters. 
    The syntax for initializing a variable in C# is: <data_type> <variable_names> = value;</p>
<h4>Accepting Values in a Program</h4>
<p>There is a particular function of the Console class that provides the function Readline() to take input from the user for storing them in a variable, which is ultimately 
a named memory location.</p>

<h3>Fields</h3>
<p>Fields are normal variable members of a class. Generally, you should declare your fields as private, then use 
    Properties to get and set their values. By this way you won't affect their values them directly. This is common 
    case practice since having public members violates the Encapsulation concept in OOP.</p>
<h3>Concatination</h3>
<p>Concatenation is the process of appending one string to the end of another string. You concatenate strings by using the + operator. For string literals and string constants, 
   concatenation occurs at compile time; no run-time concatenation occurs. For string variables, concatenation occurs only at run time.</p>

        <h2>Simple Operators and Expressions</h2>

<h3>Simple Operators</h3>
<p>C# provides a number of operators. Many of them are supported by the built-in types and allow you to perform basic operations with
     values of those types.</p>

     <p>C# operators by group</p>
     <ul>
         <li>Arithmetic Operators</li>
         <li>Comparison Operators</li>
         <li>Boolean Logical Operators</li>
         <li>Bitwise and Shift Operators</li>
         <li>Equality Operators</li>
     </ul>
     <h4>Arithmetic Operators</h4>
     <p>Arithmetic Operations can be split up between Unary and Binary numeric types</p>
     <h6>Unary</h6>
     <ul>
         <li>++ (increment)</li>
         <li>-- (decrement)</li>
         <li>+ (plus)</li>
         <li>- (minus)</li>
     </ul>
     <h6>Binary</h6>
     <ul>
         <li>* (multiplication)</li>
         <li>/ (division)</li>
         <li>% (remainder)</li>
         <li>+ (addition)</li>
         <li>- (subtraction)</li>
     </ul>

     <h4>Comparison Operators</h4>
     <p>The < (less than), > (greater than), <= (less than or equal), and >= (greater than or equal) comparison, also known as relational, 
        operators compare their operands. Those operators are supported by all integral and floating-point numeric types.</p>
        
        <h6>List of Comparison Operators</h6>
        <ul>
            <li> < - returns true if its left-hand operand is less than its right-hand operand, false otherwise</li>
            <li> > - retruns true if its left-hand operand is greater than its right-hand operan, false otherwise</li>
            <li> <= - returns ture if its left-hand operand is less than or equal to its right-hand operand, false otherwise</li>
            <li> >= - returns true if its left-hand operand is greater than or equal to its right-hand operand, false otherwise</li>
        </ul>

    <h5>Important Operator Overloadability note</h5>
        <p>
            A user-defined type can overload the <, >, <=, and >= operators.
            
            If a type overloads one of the < or > operators, it must overload both < and >. If a type overloads one of the <= or >= operators, 
            it must overload both <= and >=.</p>

     <h4>Boolean Logical Operators</h4>
     <h6> Unary B.L.O. </h6>
     <ul>
         <li>! (logical negation) operators</li>
     </ul>

     <h6> Binary B.L.O</h6>
     <ul>
         <li>& (logical AND)</li>
         <li>| (logical OR)</li>
         <li> ^ (logical exclusive OR)</li>
         <li> && (conditional logical AND)</li>
         <li>|| (conditional logical OR)</li>
     </ul>

     <h4>Bitwise and Shift Operators</h4>
     <h6>Unary B.S.O</h6>
     <ul>
         <li>~ (bitwise complement) operator</li>
     </ul>
     <h6>Binary B.S.O</h6>
     <ul>
         <li> << (left shift)</li>
         <li> >> (right shift)</li>
         <li> & (logical AND)</li>
         <li> | (logical OR)</li>
         <li> ^ (logical exclusive OR)</li>
     </ul>
     <h4>Equality Operators</h4>
     <p>The == (equality) and != (inequality) operators check if their operands are equal or not.</p>

<h2>if/else and Conditional+Switch statements</h2>

<p>A statement that can be executed based on a condition is known as a “Conditional Statement”. The statement is often a block of code.

    The following are the 2 types:
    Conditional Branching
    Conditional Looping

    Conditional Branching
    This statement allows you to branch your code depending on whether or not a certain condition is met.
    
    In C# are the following 2 conditional branching statements:
    
    1. IF statement
    2. Switch statement</p>

<h3>If statement</h3>
<p>C# if else statement is a common selection statement. The if else in C# statement checks a Boolean expression and executes 
    the code based on if the expression is true or false. The if part of the code executes when the value of the 
    expression is true. The else part of the code is executed when the value of the expression is false. The else part 
    of the if..else is optional.</p>

<h3>Switch Statement</h3>
<p>In C#, Switch statement is a multiway branch statement. It provides an efficient way to transfer the execution to different 
    parts of a code based on the value of the expression. The switch expression is of integer type such as int, char, byte, or short, 
    or of an enumeration type, or of string type. The expression is checked for different cases and the one match is executed.</p>

    <p>Important points to remember on the list below.</p>
<ul>
    <li>In C#, duplicate case values are not allowed.</li>
    <li>The data type of the variable in the switch and value of a case must be of the same type.</li>
    <li>The value of a case must be a constant or a literal. Variables are not allowed.</li>
    <li>The break in switch statement is used to terminate the current sequence.</li>
    <li>The default statement is optional and it can be used anywhere inside the switch statement.</li>
    <li>Multiple default statements are not allowed.</li>
</ul>

<h2>C# libraries</h2>

<h2>Arrays and Targetting Indexes</h2>

<h3>Arrays</h3>
<p>An array stores lists of values in a specific order.</p>
<p>Example: local myArray = {"item1", "item2", 12, Random.Part, myVariable}</p>
<p>In the provided example, all values are inside "{}" and separated by commas.</p>

<h3>Indexes</h3>
<p>Indexers are a syntactic convenience that enable you to create a class, struct, or interface that client 
    applications can access as an array. The compiler will generate an Item property (or an alternatively named property if 
    IndexerNameAttribute is present), and the appropriate accessor methods.
     Indexers are most frequently implemented in types whose primary purpose is to encapsulate an internal collection or array. </p>

<p>An Indexer can hold multiple values.</p>

<p>For example, suppose you have a class TempRecord that represents the temperature in Fahrenheit as 
    recorded at 10 different times during a 24-hour period. The class contains a temps array of type float[] 
    to store the temperature values. By implementing an indexer in this class, clients can access the temperatures 
    in a TempRecord instance as float temp = tempRecord[4] instead of as float temp = tempRecord.temps[4]. 
    The indexer notation not only simplifies the syntax for client applications; it also makes the class, and its 
    purpose more intuitive for other developers to understand.

    To declare an indexer on a class or struct, use the "this" keyword</p>

    <p>List of Indexer qualities.</p>
<ul>
    <li>Allows elements of an internal collection of an object to be accessed by using array notation on the object itself.</li>
<li>Accessed through an index.</li>
<li>Must be an instance member.</li>
<li>A get accessor of an indexer has the same formal paremeter list as the indexer.</li>
<li>A set accessor of an indexer has the same formal parameter list as the indexer, and also to the value parameter.</li>
<li>Supports expression bodied members for get only indexers.</li>
</ul>






</body>