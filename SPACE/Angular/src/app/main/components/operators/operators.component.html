<h1>Introducing Simple Operators</h1>

<h3>Simple Operators</h3>
<p>C# provides a number of operators. Many of them are supported by the built-in types and allow you to perform basic operations with
     values of those types.</p>

     <p>C# operators by group</p>
     <ul>
         <li>Arithmetic Operators</li>
         <li>Comparison Operators</li>
         <li>Boolean Logical Operators</li>
         <li>Bitwise and Shift Operators</li>
         <li>Equality Operators</li>
     </ul>
     <h4>Arithmetic Operators</h4>
     <p>Arithmetic Operations can be split up between Unary and Binary numeric types</p>
     <h6>Unary</h6>
     <ul>
         <li>++ (increment)</li>
         <li>-- (decrement)</li>
         <li>+ (plus)</li>
         <li>- (minus)</li>
     </ul>
     <h6>Binary</h6>
     <ul>
         <li>* (multiplication)</li>
         <li>/ (division)</li>
         <li>% (remainder)</li>
         <li>+ (addition)</li>
         <li>- (subtraction)</li>
     </ul>

     <h4>Comparison Operators</h4>
     <p>The < (less than), > (greater than), <= (less than or equal), and >= (greater than or equal) comparison, also known as relational,
        operators compare their operands. Those operators are supported by all integral and floating-point numeric types.</p>

        <h6>List of Comparison Operators</h6>
        <ul>
            <li> < - returns true if its left-hand operand is less than its right-hand operand, false otherwise</li>
            <li> > - retruns true if its left-hand operand is greater than its right-hand operan, false otherwise</li>
            <li> <= - returns ture if its left-hand operand is less than or equal to its right-hand operand, false otherwise</li>
            <li> >= - returns true if its left-hand operand is greater than or equal to its right-hand operand, false otherwise</li>
        </ul>

    <h5>Important Operator Overloadability note</h5>
        <p>
            A user-defined type can overload the <, >, <=, and >= operators.

            If a type overloads one of the < or > operators, it must overload both < and >. If a type overloads one of the <= or >= operators,
            it must overload both <= and >=.</p>

     <h4>Boolean Logical Operators</h4>
     <h6> Unary B.L.O. </h6>
     <ul>
         <li>! (logical negation) operators</li>
     </ul>

     <h6> Binary B.L.O</h6>
     <ul>
         <li>& (logical AND)</li>
         <li>| (logical OR)</li>
         <li> ^ (logical exclusive OR)</li>
         <li> && (conditional logical AND)</li>
         <li>|| (conditional logical OR)</li>
     </ul>

     <h4>Bitwise and Shift Operators</h4>
     <h6>Unary B.S.O</h6>
     <ul>
         <li>~ (bitwise complement) operator</li>
     </ul>
     <h6>Binary B.S.O</h6>
     <ul>
         <li> << (left shift)</li>
         <li> >> (right shift)</li>
         <li> & (logical AND)</li>
         <li> | (logical OR)</li>
         <li> ^ (logical exclusive OR)</li>
     </ul>
     <h4>Equality Operators</h4>
     <p>The == (equality) and != (inequality) operators check if their operands are equal or not.</p>

     <h3>Strings</h3>
<p>The string data type is used to store a sequence of characters (text). String values must be surrounded by double quotes("").</p>

     <h2>Arrays and Targetting Indexes</h2>

<h3>Arrays</h3>
<p>An array stores lists of values in a specific order.</p>
<p>Example: local myArray = "item1", "item2", 12, Random.Part, myVariable</p>
<p>In the provided example, all values are inside brackets and separated by commas.</p>

<h3>Indexes</h3>
<p>Indexers are a syntactic convenience that enable you to create a class, struct, or interface that client
    applications can access as an array. The compiler will generate an Item property (or an alternatively named property if
    IndexerNameAttribute is present), and the appropriate accessor methods.
     Indexers are most frequently implemented in types whose primary purpose is to encapsulate an internal collection or array. </p>

<p>An Indexer can hold multiple values.</p>

<p>For example, suppose you have a class TempRecord that represents the temperature in Fahrenheit as
    recorded at 10 different times during a 24-hour period. The class contains a temps array of type float[]
    to store the temperature values. By implementing an indexer in this class, clients can access the temperatures
    in a TempRecord instance as float temp = tempRecord[4] instead of as float temp = tempRecord.temps[4].
    The indexer notation not only simplifies the syntax for client applications; it also makes the class, and its
    purpose more intuitive for other developers to understand.

    To declare an indexer on a class or struct, use the "this" keyword</p>

    <p>List of Indexer qualities.</p>
<ul>
    <li>Allows elements of an internal collection of an object to be accessed by using array notation on the object itself.</li>
<li>Accessed through an index.</li>
<li>Must be an instance member.</li>
<li>A get accessor of an indexer has the same formal paremeter list as the indexer.</li>
<li>A set accessor of an indexer has the same formal parameter list as the indexer, and also to the value parameter.</li>
<li>Supports expression bodied members for get only indexers.</li>
</ul>
